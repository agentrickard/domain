<?php

/**
 * @file
 * Domain-based path rewrites for content.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Routing\TrustedRedirectResponse;

/**
 * Defines the name of the source domain field.
 */
const DOMAIN_SOURCE_FIELD = 'field_domain_source';

/**
 * Creates our fields for an entity bundle.
 *
 * @param string $entity_type
 *   The entity type being created. Node and user are supported.
 * @param string $bundle
 *   The bundle being created.
 *
 * @see domain_source_node_type_insert()
 * @see domain_source_install()
 */
function domain_source_confirm_fields($entity_type, $bundle) {
  $id = $entity_type . '.' . $bundle . '.' . DOMAIN_SOURCE_FIELD;
  $field_config_storage = \Drupal::entityTypeManager()->getStorage('field_config');

  if (!$field = $field_config_storage->load($id)) {
    $field = array(
      'field_name' => DOMAIN_SOURCE_FIELD,
      'entity_type' => $entity_type,
      'label' => 'Domain Source',
      'bundle' => $bundle,
      'required' => FALSE,
      'description' => 'Select the canonical domain for this content.',
      'settings' => array(
        'handler_settings' => array(
          'sort' => array('field' => 'weight', 'direction' => 'ASC'),
        ),
      ),
    );
    $field_config = $field_config_storage->create($field);
    $field_config->save();
  }

  // Tell the form system how to behave. Default to radio buttons.
  // @TODO: This function is deprecated, but using the OO syntax is causing
  // test fails.
  entity_get_form_display($entity_type, $bundle, 'default')
    ->setComponent(DOMAIN_SOURCE_FIELD, array(
      'type' => 'options_select',
      'weight' => 40,
    ))
    ->save();
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 *
 * Creates our fields when new node types are created.
 *
 * @TODO: Make this possible for all entity types.
 */
function domain_source_node_type_insert(EntityInterface $entity) {
  domain_source_confirm_fields('node', $entity->id());
}

/**
 * Returns the source domain associated to an entity.
 *
 * @param Drupal\Core\Entity\EntityInterface $entity
 *   The entity to check.
 *
 * @return string|NULL
 *   The value assigned to the entity, either a domain id string or NULL.
 */
function domain_source_get(EntityInterface $entity) {
  $source = NULL;
  $value = $entity->get(DOMAIN_SOURCE_FIELD)->offsetGet(0);
  if (!empty($value)) {
    $target_id = $value->target_id;
    if ($domain = \Drupal::service('domain.loader')->load($target_id)) {
      $source = $domain->id();
    }
  }
  return $source;
}

/**
 * Implements hook_form_alter().
 *
 * Find forms that contain the domain source field and allow those to handle
 * redirects properly.
 */
function domain_source_form_alter(&$form, &$form_state, $form_id) {
  $object = $form_state->getFormObject();
  // Set up our TrustedRedirect handler for form saves.
  if (isset($form[DOMAIN_SOURCE_FIELD]) && !empty($object) && is_callable([$object, 'getEntity']) && $entity = $object->getEntity()) {
    foreach ($form['actions'] as $key => $element) {
      // Redirect submit handlers, but not the preview button.
      if ($key != 'preview' && isset($element['#type']) && $element['#type'] == 'submit') {
        $form['actions'][$key]['#submit'][] = 'domain_source_form_submit';
      }
    }
  }
}

/**
 * Redirect form submissions to other domains.
 */
function domain_source_form_submit(&$form, \Drupal\Core\Form\FormStateInterface $form_state) {
  // Ensure that we have saved an entity.
  if ($object = $form_state->getFormObject()) {
    $url = $object->getEntity()->url();
  }
  // Validate that the URL will be considered "external" by Drupal, which means
  // that a scheme value will be present.
  if (!empty($url)) {
    $uri_parts = parse_url($url);
    // If necessary, issue a TrustedRedirectResponse to the new URL.
    if (!empty($uri_parts['scheme'])) {
      $response = new TrustedRedirectResponse($url);
      $form_state->setResponse($response);
    }
  }
}
